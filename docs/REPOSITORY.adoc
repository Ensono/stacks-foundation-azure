= Stacks Foundation Azure Repository Guide
:toc: left
:toclevels: 3
:icons: font
:source-highlighter: rouge
:last-update-label!:

== Overview

This repository contains the **Stacks Foundation Azure Terraform Module** - a foundational module that provides standardized naming conventions and regional configurations for Azure infrastructure deployments across Ensono Stacks projects.

This guide covers how to work with **this repository**, including the build system, development workflow, and contribution guidelines.

[NOTE]
====
For documentation on **using the module** in your infrastructure deployments, see the module README that is packaged with the distribution.
====

== Repository Structure

[source]
----
stacks-foundation-azure/
├── src/                          # Terraform source code
│   ├── naming.tf                 # Azure naming module integration
│   ├── regions.tf                # Azure regions configuration
│   ├── variables.tf              # Input variables
│   ├── outputs.tf                # Module outputs
│   ├── locals.tf                 # Local values and transformations
│   ├── random_string.tf          # Unique seed generation
│   ├── time_static.tf            # State time tracking
│   ├── envvar_files.tf           # Environment file generation
│   └── providers.tf              # Provider configuration
├── templates/                    # Template files for env generation
│   ├── envvars.bash.tpl          # Bash environment variables
│   ├── envvars.ps1.tpl           # PowerShell environment variables
│   └── inputs.auto.tfvars.tpl    # Terraform auto-variables
├── docs/                         # Documentation
│   ├── REPOSITORY.adoc           # This file - repo development guide
│   └── readme/                   # Module documentation (packaged)
│       ├── index.adoc            # Module readme entry point
│       └── tfdocs.adoc           # Auto-generated API docs
├── build/                        # Build system configuration
│   ├── eirctl/                   # eirctl configuration
│   │   ├── tasks.yaml            # Build task definitions
│   │   └── contexts.yaml         # Container context definitions
│   └── scripts/                  # Build scripts
│       └── Create-TFModuleZip.ps1
├── outputs/                      # Build output (gitignored)
│   ├── module/                   # Assembled module
│   ├── tmp/                      # Temporary build files
│   └── stacks-foundation-azure.zip  # Final package
├── .github/
│   └── copilot-context.md        # GitHub Copilot context file
├── .gitignore
├── .terraform-docs.yml           # terraform-docs configuration
├── eirctl.yaml                   # Build pipeline definition
└── LICENSE
----

== Build System

=== Overview

The repository uses **eirctl** (Ensono Infrastructure CLI) as its build orchestration tool. The build system:

1. Generates Terraform API documentation
2. Converts AsciiDoc documentation to Markdown
3. Assembles the distributable module
4. Creates a zip package

=== Build Pipeline

The build pipeline is defined in `eirctl.yaml`:

[source,yaml]
----
pipelines:
  build:
    - task: build:clean
    - task: terraform:docs
    - task: docs:docbook
    - task: docs:markdown
    - task: build:copy
    - task: build:package
----

==== Pipeline Tasks

[cols="1,3"]
|===
|Task |Description

|`build:clean`
|Removes the `outputs/` directory and recreates `outputs/module/`

|`terraform:docs`
|Runs `terraform-docs` to generate API documentation from Terraform source code into `docs/readme/tfdocs.adoc`

|`docs:docbook`
|Converts `docs/readme/index.adoc` to DocBook XML format at `outputs/tmp/README.xml`

|`docs:markdown`
|Converts DocBook XML to GitHub-flavored Markdown at `outputs/module/README.md`

|`build:copy`
|Copies all files from `src/*` to `outputs/module/`

|`build:package`
|Creates `outputs/stacks-foundation-azure.zip` from `outputs/module/`
|===

=== Running the Build

[source,bash]
----
# Run the complete build pipeline
eirctl build

# Run individual tasks
eirctl run terraform:docs
eirctl run docs:markdown
----

=== Build Contexts

The build uses containerized contexts defined in `build/eirctl/contexts.yaml`:

[cols="1,2,3"]
|===
|Context |Container |Purpose

|`powershell`
|`ensono/eir-foundation-powershell`
|PowerShell tasks (clean, copy, package)

|`infra`
|`ensono/eir-infrastructure`
|Terraform tooling (terraform-docs)

|`asciidoc`
|`ensono/eir-asciidoctor`
|Documentation conversion (asciidoctor, pandoc)
|===

=== Build Output

After running `eirctl build`, the following are created in `outputs/`:

[cols="1,3"]
|===
|Path |Contents

|`outputs/module/`
|Complete module with all `.tf` files and `README.md`

|`outputs/module/README.md`
|Module documentation converted to Markdown from AsciiDoc

|`outputs/tmp/README.xml`
|Intermediate DocBook XML (for conversion)

|`outputs/stacks-foundation-azure.zip`
|Distributable package containing the complete module
|===

[IMPORTANT]
====
The `outputs/` directory is gitignored and should not be committed to version control.
====

== Documentation System

=== Two Documentation Sets

This repository maintains **two separate documentation sets**:

==== 1. Repository Documentation (This File)

- **Location:** `docs/REPOSITORY.adoc`
- **Audience:** Developers working on this repository
- **Purpose:** Build system, development workflow, contribution guidelines
- **Distribution:** Not included in the module package

==== 2. Module Documentation

- **Location:** `docs/readme/index.adoc` (and included files)
- **Audience:** Users consuming the Terraform module
- **Purpose:** Module usage, API reference, examples
- **Distribution:** Packaged as `README.md` in the zip file

=== Documentation Workflow

[source]
----
1. Edit AsciiDoc source files
   ├── docs/REPOSITORY.adoc (repository guide)
   └── docs/readme/index.adoc (module guide)

2. terraform-docs generates API docs
   └── docs/readme/tfdocs.adoc

3. AsciiDoc → DocBook → Markdown conversion
   └── outputs/module/README.md

4. Package with module
   └── outputs/stacks-foundation-azure.zip
----

=== Editing Documentation

==== Module Documentation

[source,bash]
----
# Edit the module documentation
vim docs/readme/index.adoc

# The index.adoc includes tfdocs.adoc which is auto-generated
# Build to regenerate
eirctl build
----

==== API Documentation

API documentation is **auto-generated** from Terraform code using `terraform-docs`:

- Configuration: `.terraform-docs.yml`
- Output: `docs/readme/tfdocs.adoc`
- Format: AsciiDoc tables
- Includes: Requirements, Providers, Modules, Resources, Inputs, Outputs

To update API docs:

1. Modify Terraform files in `src/`
2. Run `eirctl run terraform:docs`

==== Repository Documentation

[source,bash]
----
# Edit this file
vim docs/REPOSITORY.adoc

# This file is NOT included in the module package
# It's for repository development only
----

== Development Workflow

=== Prerequisites

- **eirctl** - Ensono Infrastructure CLI installed
- **Docker** - For running containerized build tasks
- **Git** - Version control

=== Making Changes

==== 1. Modify Terraform Code

[source,bash]
----
# Edit source files
vim src/naming.tf

# Validate syntax
terraform fmt src/
terraform validate
----

==== 2. Update Documentation

[source,bash]
----
# If you changed variables/outputs, API docs auto-update
# If you need to update usage guide:
vim docs/readme/index.adoc
----

==== 3. Build and Test

[source,bash]
----
# Build the module
eirctl build

# Check the output
ls -la outputs/module/
cat outputs/module/README.md

# Test by extracting and using the module
unzip outputs/stacks-foundation-azure.zip -d test/
cd test/
terraform init
terraform plan
----

==== 4. Commit Changes

[source,bash]
----
git add src/ docs/
git commit -m "feat: description of changes"
git push
----

=== Adding New Features

==== Adding a New Variable

[source,hcl]
----
# 1. Add to src/variables.tf
variable "new_feature" {
  description = <<DESCRIPTION
Detailed description of what this variable does.
DESCRIPTION
  type        = string
  default     = "default_value"
}

# 2. Use in src/locals.tf or src/naming.tf
# 3. Build to update API docs
eirctl build

# 4. Update usage examples in docs/readme/index.adoc if needed
----

==== Adding Extended Resource Types

To add custom naming for Azure resources not in the base naming module:

[source,hcl]
----
# Edit src/locals.tf - extended_naming_map
extended_naming_map = {
  for comp_k, comp_v in module.azure_naming : comp_k => {
    # ... existing entries ...
    
    "new_resource_type" = {
      name = replace(
        lookup(module.azure_naming[comp_k], "storage_account", {}).name_unique,
        regex("^.{2}", lookup(module.azure_naming[comp_k], "storage_account", {}).name_unique),
        "nrt"  # New resource type abbreviation
      )
    },
  }
}
----

==== Adding Output Values

[source,hcl]
----
# Add to src/outputs.tf
output "new_output" {
  description = "Description of the output"
  value       = local.some_computed_value
}

# Build to update API docs
eirctl build
----

=== Testing Changes

==== Local Testing

[source,bash]
----
# Create a test directory
mkdir -p test/consumer

# Create a test configuration
cat > test/consumer/main.tf <<EOF
module "foundation" {
  source = "../../outputs/module"
  
  company_name = "TestCo"
  location     = "uksouth"
  project      = ["test"]
  stage_name   = "foundation"
  environment  = "dev"
}

output "test_names" {
  value = module.foundation.names
}
EOF

# Initialize and plan
cd test/consumer
terraform init
terraform plan
----

==== Workspace Testing

[source,bash]
----
# Test with different workspaces
terraform workspace new dev
terraform plan

terraform workspace new prod
terraform plan

# Verify naming differences
----

==== Unit Testing

The repository includes comprehensive unit tests using Terraform's native test framework (available in Terraform 1.6.0+).

===== Running Tests

[source,bash]
----
# Run all tests
cd src
terraform test

# Run specific test file
terraform test tests/basic_naming.tftest.hcl

# Run with verbose output
terraform test -verbose
----

===== Test Structure

Tests are located in `src/tests/` and cover:

[cols="1,3"]
|===
|Test File |Coverage

|`basic_naming.tftest.hcl`
|Basic naming functionality, outputs, and seed generation

|`multi_project.tftest.hcl`
|Multiple projects in a single deployment

|`short_name_length.tftest.hcl`
|Short name length configuration (default, custom, minimum)

|`region_filtering.tftest.hcl`
|Region filtering by recommendation and geography

|`outputs_validation.tftest.hcl`
|Output structure and availability

|`extended_naming.tftest.hcl`
|Extended resource naming (Fabric, AI services, Front Door, etc.)

|`env_file_generation.tftest.hcl`
|Environment file generation (partial - see limitations below)

|`workspace_naming.tftest.hcl`
|Workspace-based naming differentiation
|===

===== Test Implementation Details

All tests use `command = apply` to create actual resources during testing. This approach:

* **Allows validation of computed values** - Resource outputs, random strings, and module-generated values are only available after apply
* **Ensures real-world behavior** - Tests validate that resources can actually be created
* **Auto-cleanup** - Terraform test framework automatically destroys resources after each test run

[IMPORTANT]
====
Tests do **not** create actual Azure resources. The module only generates naming conventions and configuration data using:

* `random_string` resources (for unique seeds)
* `time_static` resources (for state timestamps)  
* `local_file` resources (for environment files, when enabled)
* Data sources from `azapi_client_config` (for Azure tenant/subscription info)

No billable Azure resources are created during testing.
====

===== Test Limitations

Some tests have limitations due to Terraform test framework constraints:

**Environment File Generation Tests**

The `env_file_generation.tftest.hcl` tests have `generate_env_files = false` because:

* The `templatefile()` function requires template files to be part of the configuration source code
* When tests run, `path.module` resolves to the test execution context (`.`), not the module source directory
* Template files in `../templates/` are not accessible from the test context
* This is a Terraform limitation, not a module issue

**Workaround for env file testing:**

[source,bash]
----
# Test env file generation manually
cd src

terraform init
terraform apply -var="company_name=TestCo" \
  -var="location=uksouth" \
  -var='project=["webapp"]' \
  -var="stage_name=foundation" \
  -var="environment=dev" \
  -var="generate_env_files=true" \
  -var='outputs={"dev":{"test_key":"test_value"}}'

# Check generated files
ls -la outputs/terraform/
----

===== Expected Test Results

When running `terraform test`, you should see:

[source]
----
Success! 16 passed, 0 failed.
----

All tests should pass. If any tests fail, check:

1. Terraform version (must be 1.6.0+)
2. Azure CLI authentication (for `azapi_client_config` data source)
3. Network connectivity to Azure
4. Provider plugin versions

===== Test Coverage Matrix

Terraform's native test framework does not provide built-in code coverage reports. Use this matrix to manually track test coverage across module features:

[cols="2,1,1,3"]
|===
|Feature/Component |Tested |Test File |Notes

|**Core Naming**
|
|
|

|Basic resource naming
|✅
|`basic_naming.tftest.hcl`
|Validates names, extended_names, regions outputs

|Company name shortening
|✅
|`basic_naming.tftest.hcl`
|Tests `var.short_name_length` (default 4 chars)

|Random seed generation
|✅
|`basic_naming.tftest.hcl`
|Validates 4-character lowercase seed

|State timestamp
|✅
|`basic_naming.tftest.hcl`
|Verifies `time_static` resource output

|**Project Configuration**
|
|
|

|Single project
|✅
|`basic_naming.tftest.hcl`
|Tests with one project in `var.project`

|Multiple projects
|✅
|`multi_project.tftest.hcl`
|Tests 3 projects simultaneously

|Project name validation
|⚠️
|_Manual testing required_
|No automated tests for invalid project names

|**Short Name Length**
|
|
|

|Default length (4 chars)
|✅
|`short_name_length.tftest.hcl`
|Uses default `var.short_name_length`

|Custom length (6 chars)
|✅
|`short_name_length.tftest.hcl`
|Tests custom short name length

|Minimum length (1 char)
|✅
|`short_name_length.tftest.hcl`
|Edge case: shortest possible name

|Maximum length
|❌
|_Not tested_
|Consider adding test for max length

|**Region Configuration**
|
|
|

|Default region (location)
|✅
|`basic_naming.tftest.hcl`
|Tests with `var.location = "uksouth"`

|Recommendation filter enabled
|✅
|`region_filtering.tftest.hcl`
|Tests `region_recommend_filter = true`

|Geography filter (Europe)
|✅
|`region_filtering.tftest.hcl`
|Tests `region_geography = "Europe"`

|No filters
|✅
|`region_filtering.tftest.hcl`
|Tests with all regions available

|Custom AVM region version
|⚠️
|_Manual testing required_
|No automated test for `var.avm_region_version`

|**Extended Naming**
|
|
|

|Fabric resources
|✅
|`extended_naming.tftest.hcl`
|Tests fabric_capacity, workspace, lakehouse

|AI services
|✅
|`extended_naming.tftest.hcl`
|Tests ai_services, ai_foundry, ai_foundry_project

|Front Door resources
|✅
|`extended_naming.tftest.hcl`
|Tests firewall_policy, endpoint, security_policy

|Managed Identity
|✅
|`extended_naming.tftest.hcl`
|Tests managed_identity naming

|Key Vault v2
|✅
|`extended_naming.tftest.hcl`
|Tests key_vault_v2 naming

|Private DNS VNet Link
|✅
|`extended_naming.tftest.hcl`
|Tests private_dns_zone_virtual_network_link

|Custom prefix override
|✅
|`extended_naming.tftest.hcl`
|Tests `var.custom_prefix` for extended resources

|**Outputs**
|
|
|

|names output
|✅
|`outputs_validation.tftest.hcl`
|Validates standard naming output structure

|extended_names output
|✅
|`outputs_validation.tftest.hcl`
|Validates extended naming output

|regions output
|✅
|`outputs_validation.tftest.hcl`
|Validates regions data output

|seed output
|✅
|`outputs_validation.tftest.hcl`
|Validates random seed output

|state_time output
|✅
|`outputs_validation.tftest.hcl`
|Validates state timestamp output

|computed_outputs
|✅
|`outputs_validation.tftest.hcl`
|Validates merged outputs structure

|**Environment Files**
|
|
|

|Disabled by default
|✅
|`env_file_generation.tftest.hcl`
|Tests `generate_env_files = false` (default)

|Bash template generation
|⚠️
|_Limited coverage_
|Templates not accessible from test context

|PowerShell template generation
|⚠️
|_Limited coverage_
|Templates not accessible from test context

|Terraform vars template
|⚠️
|_Limited coverage_
|Templates not accessible from test context

|Output encoding (JSON)
|✅
|`env_file_generation.tftest.hcl`
|Tests list/map JSON encoding

|Hyphen to underscore conversion
|✅
|`env_file_generation.tftest.hcl`
|Tests key normalization in outputs

|**Workspace Integration**
|
|
|

|Workspace in naming suffix
|✅
|`workspace_naming.tftest.hcl`
|Tests workspace name in generated names

|Different workspaces
|✅
|`workspace_naming.tftest.hcl`
|Validates workspace differentiation

|Default workspace
|⚠️
|_Manual testing required_
|No test for "default" workspace behavior

|**Stage Name**
|
|
|

|Foundation stage
|✅
|Multiple test files
|Most tests use `stage_name = "foundation"`

|Networking stage
|✅
|`env_file_generation.tftest.hcl`
|Tests `stage_name = "networking"`

|Custom stage names
|⚠️
|_Manual testing required_
|No comprehensive test coverage

|**Edge Cases & Validation**
|
|
|

|Empty project list
|❌
|_Not tested_
|Should test `var.project = []`

|Invalid location
|❌
|_Not tested_
|Should test non-existent Azure region

|Special characters in inputs
|❌
|_Not tested_
|Should test input sanitization

|Very long company names
|❌
|_Not tested_
|Should test truncation behavior

|Outputs with null environment
|❌
|_Not tested_
|Should test missing environment in outputs JSON

|===

**Legend:**

* ✅ = Fully tested with automated tests
* ⚠️ = Partially tested or requires manual testing
* ❌ = Not tested (gap in coverage)

**Coverage Summary:**

* **Strong Coverage**: Core naming, project configuration, short names, regions, extended naming, outputs
* **Adequate Coverage**: Workspace integration, basic env file generation
* **Coverage Gaps**: Edge cases, input validation, template file generation, error handling

**Recommendations for Improving Coverage:**

1. Add validation tests for invalid inputs (empty projects, bad regions, etc.)
2. Add edge case tests for boundary conditions
3. Consider integration tests for env file generation (requires manual execution)
4. Add tests for all supported `stage_name` values
5. Test workspace edge cases (default workspace, special characters)
6. Add negative tests using `expect_failures` for validation blocks

[TIP]
====
When adding new features, update this coverage matrix and create corresponding test files to maintain test coverage.
====

=== Version Management

==== Module Dependencies

The module uses external dependencies:

[source,hcl]
----
# src/naming.tf
module "azure_naming" {
  source  = "Azure/naming/azurerm"
  # Note: No version constraint - uses latest available
}

# src/regions.tf
module "azure_regions" {
  source  = "Azure/avm-utl-regions/azurerm"
  version = "0.5.0"  # Controlled by var.avm_region_version
}
----

[IMPORTANT]
====
When updating module versions:

1. Test thoroughly with multiple projects
2. Check for breaking changes
3. Update documentation
4. Consider the impact on consuming infrastructure
====

==== Release Process

[source,bash]
----
# 1. Update version references if needed
# 2. Build the module
eirctl build

# 3. Tag the release
git tag -a v1.2.3 -m "Release version 1.2.3"
git push origin v1.2.3

# 4. Distribute the zip file
cp outputs/stacks-foundation-azure.zip releases/v1.2.3/
----

== Build Configuration

=== terraform-docs Configuration

File: `.terraform-docs.yml`

[source,yaml]
----
formatter: "asciidoc"

output:
  file: "../docs/readme/tfdocs.adoc"
  mode: inject

settings:
  anchor: true
  color: true
  default: true
  required: true
  sensitive: true
  type: true
----

=== eirctl Task Configuration

File: `build/eirctl/tasks.yaml`

Key tasks:

[source,yaml]
----
terraform:docs:
  context: infra
  command:
    - terraform-docs -c .terraform-docs.yml src/

docs:docbook:
  context: asciidoc
  command:
    - asciidoctor -b docbook -o outputs/tmp/README.xml docs/readme/index.adoc

docs:markdown:
  context: asciidoc
  command:
    - pandoc -f docbook -t gfm -o outputs/module/README.md outputs/tmp/README.xml
----

== Troubleshooting

=== Build Failures

==== terraform-docs fails

[source,bash]
----
# Check Terraform syntax
terraform fmt -check src/
terraform validate

# Run terraform-docs directly
eirctl run terraform:docs
----

==== Asciidoctor conversion fails

[source,bash]
----
# Validate AsciiDoc syntax
asciidoctor -v docs/readme/index.adoc

# Check for missing includes
grep "^include::" docs/readme/index.adoc
----

==== Docker context issues

[source,bash]
----
# Verify Docker is running
docker ps

# Check eirctl contexts
eirctl context list

# Pull required containers
docker pull ensono/eir-infrastructure
docker pull ensono/eir-asciidoctor
docker pull ensono/eir-foundation-powershell
----

=== Common Issues

==== Changes not appearing in README.md

[source,bash]
----
# Ensure you edited docs/readme/index.adoc, not outputs/module/README.md
# The README.md is generated, not edited directly

# Rebuild
eirctl run build:clean
eirctl build
----

==== Module not updating in consumer projects

[source,bash]
----
# In the consumer project:
rm -rf .terraform/
terraform init -upgrade

# Or specify exact module path
module "foundation" {
  source = "../stacks-foundation-azure/outputs/module"
}
----

== Best Practices

=== Code Style

- Use `terraform fmt` before committing
- Add descriptions to all variables and outputs
- Comment complex local transformations
- Keep lines under 120 characters

=== Documentation

- Update API docs by rebuilding (don't edit `tfdocs.adoc` manually)
- Keep module docs focused on usage
- Keep repository docs focused on development
- Use examples liberally
- Document breaking changes prominently

=== Testing

- Test with multiple projects in `var.project`
- Test with different regions
- Test with different workspace names
- Verify name lengths for Azure resource limits
- Test environment file generation

=== Git Workflow

[source,bash]
----
# Create feature branch
git checkout -b feature/new-capability

# Make changes and test
# ...

# Commit with conventional commits
git commit -m "feat(naming): add support for new resource type"
git commit -m "docs: update usage examples"
git commit -m "fix(regions): correct geography filter"

# Push and create PR
git push origin feature/new-capability
----

=== Commit Message Convention

- `feat:` - New feature
- `fix:` - Bug fix
- `docs:` - Documentation changes
- `refactor:` - Code refactoring
- `test:` - Test updates
- `build:` - Build system changes
- `chore:` - Maintenance tasks

== Contributing

=== Pull Request Process

1. **Fork or branch** - Create a feature branch
2. **Make changes** - Follow code style and conventions
3. **Update docs** - Both API and usage documentation
4. **Build** - Run `eirctl build` successfully
5. **Test** - Verify with test infrastructure
6. **Commit** - Use conventional commit messages
7. **PR** - Submit pull request with description

=== Code Review Checklist

- [ ] Terraform code is formatted (`terraform fmt`)
- [ ] Variables have descriptions
- [ ] Changes are documented
- [ ] Build succeeds (`eirctl build`)
- [ ] Breaking changes are noted
- [ ] Examples are updated if needed
- [ ] Tests pass (if applicable)

== Advanced Topics

=== Custom Build Tasks

Add custom tasks to `build/eirctl/tasks.yaml`:

[source,yaml]
----
tasks:
  custom:validate:
    description: Validate Terraform and documentation
    context: infra
    command: |
      terraform fmt -check src/
      terraform validate
----

=== Extending the Module

The module is designed to be extended. Common extension points:

1. **Extended naming** - Add more resource types in `locals.tf`
2. **Additional outputs** - Expose more computed values
3. **Template files** - Add new template formats
4. **Region filters** - Enhance region selection logic

=== Integration with CI/CD

[source,yaml]
----
# Example GitHub Actions workflow
name: Build Module
on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Build module
        run: |
          eirctl build
      - name: Upload artifact
        uses: actions/upload-artifact@v2
        with:
          name: module-package
          path: outputs/stacks-foundation-azure.zip
----

== Support and Resources

=== Internal Resources

- **Ensono Stacks Documentation** - Main stacks documentation
- **eirctl Documentation** - Build tool reference
- **Team Wiki** - Internal best practices

=== External Resources

- https://registry.terraform.io/modules/Azure/naming/azurerm[Azure Naming Module]
- https://registry.terraform.io/modules/Azure/avm-utl-regions/azurerm[Azure Regions Utility]
- https://terraform-docs.io/[terraform-docs]
- https://asciidoctor.org/[Asciidoctor]

== License

Copyright (c) 2025 Ensono

This project is licensed under the MIT License. See the `LICENSE` file for details.
