== Development Workflow

=== Prerequisites

- **eirctl** - Ensono Infrastructure CLI installed
- **Docker** - For running containerized build tasks
- **Git** - Version control

=== Making Changes

==== 1. Modify Terraform Code

[source,bash]
----
# Edit source files
vim src/naming.tf

# Validate syntax
terraform fmt src/
terraform validate
----

==== 2. Update Documentation

[source,bash]
----
# If you changed variables/outputs, API docs auto-update
# If you need to update usage guide:
vim docs/readme/index.adoc
----

==== 3. Build and Test

[source,bash]
----
# Build the module
eirctl build

# Check the output
ls -la outputs/module/
cat outputs/module/README.md

# Test by extracting and using the module
unzip outputs/stacks-foundation-azure.zip -d test/
cd test/
terraform init
terraform plan
----

==== 4. Commit Changes

[source,bash]
----
git add src/ docs/
git commit -m "feat: description of changes"
git push
----

=== Adding New Features

==== Adding a New Variable

[source,hcl]
----
# 1. Add to src/variables.tf
variable "new_feature" {
  description = <<DESCRIPTION
Detailed description of what this variable does.
DESCRIPTION
  type        = string
  default     = "default_value"
}

# 2. Use in src/locals.tf or src/naming.tf
# 3. Build to update API docs
eirctl build

# 4. Update usage examples in docs/readme/index.adoc if needed
----

==== Adding Extended Resource Types

To add custom naming for Azure resources not in the base naming module:

[source,hcl]
----
# Edit src/locals.tf - extended_naming_map
extended_naming_map = {
  for comp_k, comp_v in module.azure_naming : comp_k => {
    # ... existing entries ...
    
    "new_resource_type" = {
      name = replace(
        lookup(module.azure_naming[comp_k], "storage_account", {}).name_unique,
        regex("^.{2}", lookup(module.azure_naming[comp_k], "storage_account", {}).name_unique),
        "nrt"  # New resource type abbreviation
      )
    },
  }
}
----

==== Adding Output Values

[source,hcl]
----
# Add to src/outputs.tf
output "new_output" {
  description = "Description of the output"
  value       = local.some_computed_value
}

# Build to update API docs
eirctl build
----

=== Testing Changes

==== Local Testing

[source,bash]
----
# Create a test directory
mkdir -p test/consumer

# Create a test configuration
cat > test/consumer/main.tf <<EOF
module "foundation" {
  source = "../../outputs/module"
  
  company_name = "TestCo"
  location     = "uksouth"
  project      = ["test"]
  stage_name   = "foundation"
  environment  = "dev"
}

output "test_names" {
  value = module.foundation.names
}
EOF

# Initialize and plan
cd test/consumer
terraform init
terraform plan
----

==== Workspace Testing

[source,bash]
----
# Test with different workspaces
terraform workspace new dev
terraform plan

terraform workspace new prod
terraform plan

# Verify naming differences
----

=== Version Management

==== Module Dependencies

The module uses pinned versions for external dependencies:

[source,hcl]
----
# src/naming.tf
module "azure_naming" {
  source  = "Azure/naming/azurerm"
  version = "0.4.2"  # Update when needed
}

# src/regions.tf
module "azure_regions" {
  source  = "Azure/avm-utl-regions/azurerm"
  version = "0.5.0"  # Controlled by var.avm_region_version
}
----

[IMPORTANT]
====
When updating module versions:

1. Test thoroughly with multiple projects
2. Check for breaking changes
3. Update documentation
4. Consider the impact on consuming infrastructure
====

==== Release Process

[source,bash]
----
# 1. Update version references if needed
# 2. Build the module
eirctl build

# 3. Tag the release
git tag -a v1.2.3 -m "Release version 1.2.3"
git push origin v1.2.3

# 4. Distribute the zip file
cp outputs/stacks-foundation-azure.zip releases/v1.2.3/
----
